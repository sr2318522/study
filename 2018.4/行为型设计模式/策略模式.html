<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>策略模式</title>
</head>
<body>
	<h1>策略模式 将定义的一组算法封装起来,使其相互之间可以替换 封装的算法具有一定的独立性 不会随着客户端变化而变化</h1>
	<script type="text/javascript">
		var PriceStrategy=function () {
			var stragtegy={
				return30:function (price) {
					return +price+parseInt(price/100)*30;
				},
				return50:function (price) {
					return +price+parseInt(price/100)*50;
				},
				parcent90:function (price) {
					return price *100*90/10000
				},
				parcent80:function (price) {
					return price *100*80/10000
				},
				parcent50:function (price) {
					return price *100*5w0/10000
				}
			}
			return function (algorithm,price) {
				return stragtegy[algorithm]&&stragtegy[algorithm](price);
			}
		}
		/**
			策略模式最主要的特色是创建一系列策略算法,没租算法处理的业务都是相同的,只是处理的付出或者处理的结果不一样
			所以他们又是可以互相替换的,这样就解决了算法与使用者之间的耦合,在测试层面上讲 由于没租算法互相之间的独立性
			该模式更方便与每组算法进行单元测试,保证算法质量
				对于策略模式的优点可以归纳为3点,第一策略模式封装了一组代码簇,并且封装的代码互相之间独立,便于对算法的
			重复引用,提高了算法的复用率,第二策略模式与继承相比在类的继承中继承的方法是被封装在类中,因此当需求很多算法时
			就不得不创建多种类,这样会导致算法与算法的使用者耦合在一起,不利于算法的独立演化看,并且在类的外部改变类的算法的
			难度也是极大的.第三,同状态模式一样,策略模式也是一种优化分支判断语句的模式,采用策略模式对算法的封装使得算法
			更容易维护
				当然策略模式也是有其自身的缺点.由于选择哪种算法的决定权在用户,所以对于用户来说就必须了解每种算法的实现.这就
			增加了用户对策略对象的使用成本.其次,由于每种算法间相互独立,这样对于一些复杂的算法处理相同逻辑的部分无法实现共享
			这就会造成一些资源的浪费.当然你可以通过享元模式来解决
				对于分支语句的优化,目前为止我们已经学习了3中模式,分别为工厂方法模式,状态模式与策略模式.对于工厂方法模式来说,
			他是一种创建型模式,他的最终目的是创建对象.而状态模式与策略模式都是行为性模式,不过在状态模式中,其核心是对状态的控制
			来决定表现行为,所以状态之间通常是不能互相代替的,否则将产生不同的行为结果.而策略模式的核心是算法,由于每种算法
			要处理的业务逻辑相同,因此他们是可以替换的,当然策略模式并不关心使用者环境,因为同一种策略模式最终的产出结果是一定的
		**/
	</script>
</body>
</html>